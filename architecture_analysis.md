# Анализ архитектуры проекта Metrics

## Обзор проекта

Проект представляет собой систему сбора и хранения метрик, состоящую из двух основных компонентов:
- **Server** - HTTP-сервер для приема и хранения метрик
- **Agent** - агент для сбора системных метрик и отправки их на сервер

## Архитектурные принципы

### 1. Многослойная архитектура
Проект следует принципам многослойной архитектуры с четким разделением ответственности:
- **Models** - модели данных
- **Repository** - слой доступа к данным
- **Handler** - слой обработки HTTP-запросов
- **Config** - конфигурация
- **Agent** - бизнес-логика агента

### 2. Интерфейсно-ориентированный дизайн
Используется паттерн Repository с интерфейсом `Repository` для абстракции от конкретной реализации хранилища.

## Детальный анализ компонентов

### 1. Модели данных (`internal/models/metrics.go`)

**Назначение**: Определение структур данных для работы с метриками.

**Ключевые элементы**:
```go
type Metrics struct {
    ID    string   `json:"id"`
    MType string   `json:"type"`
    Delta *int64   `json:"delta,omitempty"`
    Value *float64 `json:"value,omitempty"`
    Hash  string   `json:"hash,omitempty"`
}
```

**Особенности**:
- Поддержка двух типов метрик: `Counter` и `Gauge`
- Использование указателей для `Delta` и `Value` для различения нулевых значений от неустановленных
- JSON-теги для сериализации/десериализации

### 2. Слой Repository (`internal/repository/`)

#### Интерфейс Repository (`Interface.go`)
```go
type Repository interface {
    UpdateGauge(key string, value float64) error
    UpdateCounter(key string, value int64) error
    GetGauge(key string) (float64, error)
    GetCounter(key string) (int64, error)
    GetGaugesKeys() []string
    GetCountersKeys() []string
}
```

#### Реализации:
1. **MemStorage** - in-memory хранилище
   - Использует `map[string]int64` для счетчиков
   - Использует `map[string]float64` для gauge-метрик
   - **Проблема**: Не потокобезопасно (отмечено в комментарии)

2. **FileSaver** - обертка с функциональностью сохранения в файл
   - Реализует паттерн Decorator
   - Поддерживает периодическое сохранение через `time.Ticker`
   - JSON-сериализация для файлового хранилища

### 3. Слой Handler (`internal/handler/`)

#### Основные компоненты:
1. **Handler** - основные HTTP-обработчики
   - `UpdateMetric` - обновление метрики через URL-параметры
   - `GetMetric` - получение метрики через URL-параметры
   - `UpdateJSON` - обновление метрики через JSON
   - `GetValueJSON` - получение метрики через JSON
   - `GetMain` - HTML-интерфейс для просмотра всех метрик

2. **Logger** - middleware для логирования HTTP-запросов
   - Использует `zap` для структурированного логирования
   - Логирует: URI, метод, статус, время выполнения, размер ответа

3. **Compressor** - middleware для сжатия данных
   - Поддержка gzip для запросов и ответов
   - Автоматическое определение необходимости сжатия по Content-Type

### 4. Конфигурация (`internal/config/flags.go`)

**Назначение**: Управление конфигурацией приложения.

**Ключевые элементы**:
```go
type HostAddress struct {
    Host string
    Port int
}
```

**Функциональность**:
- Парсинг адреса в формате `host:port`
- Валидация IP-адресов и портов
- Поддержка значения по умолчанию (`localhost:8080`)

### 5. Агент (`internal/agent/`)

#### Структура Agent:
```go
type Agent struct {
    Repo repository.Repository
    host config.HostAddress
}
```

#### Основные методы:
1. **Send()** - отправка метрик на сервер
   - Поддержка gzip-сжатия для запросов
   - Обработка сжатых ответов от сервера
   - Сбор ошибок в слайс для последующего анализа

2. **Add(*runtime.MemStats)** - сбор системных метрик
   - Собирает 25 различных метрик runtime памяти
   - Обновляет локальное хранилище агента

### 6. Точки входа

#### Server (`cmd/server/main.go`)
- Инициализация логгера (zap)
- Парсинг конфигурации из флагов и переменных окружения
- Создание цепочки хранилищ: MemStorage → FileSaver
- Настройка HTTP-роутера с middleware
- Запуск HTTP-сервера

#### Agent (`cmd/agent/main.go`)
- Парсинг конфигурации (адрес сервера, интервалы)
- Инициализация агента с локальным хранилищем
- Запуск двух тикеров: для сбора метрик и для отправки
- Основной цикл обработки событий

## Потоки данных

### Server Flow:
```
HTTP Request → Logger → Compressor → Handler → Repository → Storage
```

### Agent Flow:
```
Runtime Stats → Local Storage → HTTP Client → Server
                    ↓
              Periodic Send → Server
```

## Используемые технологии

### Основные зависимости:
- **go-chi/chi/v5** - HTTP роутер
- **go.uber.org/zap** - структурированное логирование
- **github.com/caarlos0/env/v11** - парсинг переменных окружения
- **compress/gzip** - сжатие данных

### Архитектурные паттерны:
1. **Repository Pattern** - абстракция доступа к данным
2. **Decorator Pattern** - FileSaver оборачивает MemStorage
3. **Middleware Pattern** - логирование и сжатие
4. **Strategy Pattern** - различные типы хранилищ

## Сильные стороны архитектуры

1. **Четкое разделение ответственности** между слоями
2. **Гибкость** - легко добавить новые типы хранилищ
3. **Производительность** - in-memory хранилище для быстрого доступа
4. **Надежность** - периодическое сохранение в файл
5. **Мониторинг** - подробное логирование всех операций
6. **Сжатие** - экономия трафика при передаче метрик

## Выявленные проблемы и рекомендации

### 1. Потокобезопасность
**Проблема**: MemStorage не потокобезопасен
**Решение**: Использовать `sync.RWMutex` или перейти на `sync.Map`

### 2. Обработка ошибок
**Проблема**: В FileSaver некоторые ошибки игнорируются
**Решение**: Добавить proper error handling и логирование

### 3. Конфигурация
**Проблема**: Дублирование кода парсинга конфигурации в server и agent
**Решение**: Вынести в отдельный config package

### 4. Тестирование
**Проблема**: Отсутствуют unit-тесты для некоторых компонентов
**Решение**: Добавить comprehensive test coverage

### 5. Структура проекта
**Проблема**: Папка `internal/service/` пуста
**Решение**: Либо удалить, либо добавить бизнес-логику

### 6. HTTP API
**Проблема**: Некоторые endpoints дублируются (POST /update и POST /update/)
**Решение**: Унифицировать API endpoints

## Заключение

Архитектура проекта демонстрирует хорошее понимание принципов чистой архитектуры и separation of concerns. Код хорошо структурирован и следует Go best practices. Основные области для улучшения - это потокобезопасность, обработка ошибок и тестирование.

Проект готов для production использования с учетом рекомендованных улучшений.
# Pool - Generic пул объектов с методом Reset()

Этот пакет реализует структуру `Pool` для переиспользования объектов с методом `Reset()`, что позволяет снизить нагрузку на garbage collector и улучшить производительность.

## Проблема с statictest

При использовании стандартной реализации `Pool[T Resetter]` возникает проблема с линтером `statictest`, который не может корректно обработать generic-типы с указателями. Для решения этой проблемы предоставляется альтернативная реализация `PoolPtr[T any]`.

## Основная реализация

```go
// Resetter определяет интерфейс для типов, которые могут быть сброшены
type Resetter interface {
    Reset()
}

// Pool представляет собой пул объектов с методом Reset()
type Pool[T Resetter] struct {
    pool sync.Pool
}

// New создаёт и возвращает указатель на структуру Pool
func New[T Resetter](newFunc func() T) *Pool[T]

// Get возвращает объект из пула
func (p *Pool[T]) Get() T

// Put помещает объект в пул с автоматическим сбросом
func (p *Pool[T]) Put(obj T)
```

## Альтернативная реализация (рекомендуется для использования со statictest)

```go
// PoolPtr представляет собой пул указателей на объекты с методом Reset()
type PoolPtr[T any] struct {
    pool sync.Pool
}

// NewPoolPtr создаёт и возвращает указатель на структуру PoolPtr
func NewPoolPtr[T any](newFunc func() *T) *PoolPtr[T]

// Get возвращает указатель на объект из пула
func (p *PoolPtr[T]) Get() *T

// Put помещает указатель на объект в пул с автоматическим сбросом
func (p *PoolPtr[T]) Put(obj *T)
```

## Пример использования

```go
// Пример структуры с методом Reset()
// generate:reset
type ExampleStruct struct {
    ID     int
    Name   string
    Active bool
    Data   []byte
}

func main() {
    // Создаём пул
    pool := NewPoolPtr(func() *ExampleStruct {
        return &ExampleStruct{
            ID:     0,
            Name:   "",
            Active: false,
            Data:   make([]byte, 0, 1024),
        }
    })

    // Получаем объект из пула
    obj := pool.Get()
    
    // Используем объект
    obj.ID = 42
    obj.Name = "Example"
    obj.Active = true
    
    // Возвращаем в пул (объект будет автоматически сброшен)
    pool.Put(obj)
}
```

## Производительность

Бенчмарки показывают значительное улучшение производительности:

- Без пула: 191.9 ns/op, 1024 B/op, 1 allocs/op
- С пулом: 17.47 ns/op, 0 B/op, 0 allocs/op

Это означает **11x ускорение** и полное отсутствие аллокаций при повторном использовании объектов.

## Интеграция с генератором Reset()

Структура Pool интегрирована с генератором методов Reset() из предыдущего инкремента. Для использования пула со структурой:

1. Добавьте комментарий `// generate:reset` к определению структуры
2. Запустите генератор: `go run cmd/reset .`
3. Используйте структуру с Pool или PoolPtr

## Файлы реализации

- `pool.go` - основная реализация Pool[T Resetter]
- `pool_alternative.go` - альтернативная реализация PoolPtr[T any]
- `pool_example.go` - примеры использования
- `pool_test.go` - тесты для основной реализации
- `pool_alternative_test.go` - тесты для альтернативной реализации
- `interface_test.go` - тесты проверки реализации интерфейса

## Рекомендации

1. **Используйте PoolPtr[T any]** для совместимости со statictest
2. **Предварительно выделяйте память** в функции-конструкторе для максимальной производительности
3. **Всегда возвращайте объекты в пул** с помощью defer, если возможно
4. **Используйте пулы для высоконагруженных операций** с частыми аллокациями

## Ограничения

- Объекты должны иметь метод `Reset()` с pointer receiver
- Пул не подходит для объектов, которые хранят ссылки на внешние ресурсы
- Необходимо быть осторожным с горутинами - один объект не должен использоваться одновременно в нескольких горутинах
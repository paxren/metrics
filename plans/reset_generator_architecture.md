# Архитектура утилиты генерации методов Reset()

## Обзор

Утилита предназначена для автоматической генерации методов Reset() для структур, помеченных комментарием `// generate:reset`. Методы Reset() сбрасывают состояние структуры к начальным значениям согласно определённым правилам.

## Архитектурная диаграмма

```mermaid
graph TD
    A[main.go] --> B[PackageScanner]
    A --> C[StructureAnalyzer]
    A --> D[CodeGenerator]
    A --> E[FileWriter]
    
    B --> F[go/packages]
    B --> G[go/ast]
    
    C --> H[TypeInspector]
    C --> I[CommentParser]
    
    D --> J[PrimitiveHandler]
    D --> K[SliceHandler]
    D --> L[MapHandler]
    D --> M[StructHandler]
    D --> N[PointerHandler]
    
    E --> O[reset.gen.go]
    
    P[Примеры структур] --> I
    Q[// generate:reset] --> I
```

## Компоненты системы

### 1. PackageScanner
- **Ответственность**: Сканирование всех пакетов проекта
- **Реализация**: Использует `go/packages` для загрузки пакетов
- **Вывод**: Список пакетов для анализа

### 2. StructureAnalyzer
- **Ответственность**: Поиск структур с комментарием `// generate:reset`
- **Реализация**: 
  - Использует `go/ast` для парсинга AST
  - Анализирует комментарии перед объявлениями структур
- **Вывод**: Список структур для генерации методов

### 3. CodeGenerator
- **Ответственность**: Генерация кода методов Reset()
- **Реализация**: Набор обработчиков для разных типов данных
- **Вывод**: Сгенерированный код методов

### 4. FileWriter
- **Ответственность**: Запись сгенерированного кода в файлы
- **Реализация**: Создание/обновление файлов `reset.gen.go`
- **Вывод**: Файлы с сгенерированными методами

## Правила генерации методов Reset()

### Примитивные типы
- `int`, `int8`, `int16`, `int32`, `int64` → `0`
- `uint`, `uint8`, `uint16`, `uint32`, `uint64` → `0`
- `float32`, `float64` → `0.0`
- `string` → `""`
- `bool` → `false`
- Указатели на примитивы → разыменование и присвоение нулевого значения

### Сложные типы
- **Слайсы**: `slice = slice[:0]` (обрезка, но не зануление)
- **Мапы**: `clear(map)` (очистка)
- **Указатели**: Проверка на nil, затем разыменование и сброс значения
- **Вложенные структуры**: Проверка наличия метода Reset() и вызов

### Пример генерации

Для структуры:
```go
// generate:reset
type ExampleStruct struct {
    i     int
    str   string
    strP  *string
    s     []int
    m     map[string]string
    child *ExampleStruct
}
```

Будет сгенерирован метод:
```go
func (es *ExampleStruct) Reset() {
    if es == nil {
        return
    }

    es.i = 0
    es.str = ""
    if es.strP != nil {
        *es.strP = ""
    }
    es.s = es.s[:0]
    clear(es.m)
    if resetter, ok := es.child.(interface{ Reset() }); ok && es.child != nil {
        resetter.Reset()
    }
}
```

## Структура файлов

### cmd/reset/main.go
Основной файл утилиты с точкой входа и оркестрацией процесса.

### Примеры структур
Будут созданы в разных пакетах для демонстрации работы утилиты:
- `internal/models/reset_examples.go`
- `internal/repository/reset_examples.go`
- `internal/handler/reset_examples.go`

### Сгенерированные файлы
- `internal/models/reset.gen.go`
- `internal/repository/reset.gen.go`
- `internal/handler/reset.gen.go`

## Алгоритм работы

1. **Сканирование пакетов**: Рекурсивное сканирование всех пакетов от корня проекта
2. **Поиск структур**: Анализ AST для поиска структур с комментарием `// generate:reset`
3. **Анализ полей**: Определение типов полей и правил сброса для каждого
4. **Генерация кода**: Создание методов Reset() согласно правилам
5. **Запись файлов**: Сохранение сгенерированных методов в файлы `reset.gen.go`

## Обработка крайних случаев

### Циклические зависимости
- Проверка на циклические ссылки между структурами
- Генерация предупреждений при обнаружении циклов

### Интерфейсы
- Проверка реализации интерфейса `interface{ Reset() }`
- Корректная обработка интерфейсных полей

### Встроенные структуры
- Обработка полей со встроенными структурами
- Рекурсивный вызов Reset() для встроенных полей

## Тестирование

### Модульные тесты
- Тесты для каждого компонента системы
- Тесты для обработчиков разных типов данных

### Интеграционные тесты
- Тесты на полных примерах структур
- Проверка корректности сгенерированного кода

### Тесты производительности
- Замер времени работы на больших проектах
- Проверка использования памяти

## Расширяемость

### Поддержка новых типов
- Легкое добавление обработчиков для новых типов
- Плагинная архитектура для кастомных правил

### Кастомные правила
- Возможность определения пользовательских правил сброса
- Конфигурационные файлы для правил генерации